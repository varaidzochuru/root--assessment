"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ExecutionPhase:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ExecutionPhaseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExecutionPhase.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EXECUTION_PHASE_UNSPECIFIED: _ExecutionPhase.ValueType  # 0
    """Do not use."""
    EXECUTION_PHASE_CLEAN: _ExecutionPhase.ValueType  # 10
    """Build/run flow phases

    Cleaning output folders (e.g. the target directory)
    """
    EXECUTION_PHASE_LOAD_PROJECT: _ExecutionPhase.ValueType  # 20
    """dbt Project loading: analyzing dbt_project, profiles.yml and scanning files"""
    EXECUTION_PHASE_PARSE: _ExecutionPhase.ValueType  # 30
    """Parsing and macro name resolution of all dbt files"""
    EXECUTION_PHASE_SCHEDULE: _ExecutionPhase.ValueType  # 40
    """Schedule nodes based on selection criteria and dependencies."""
    EXECUTION_PHASE_INIT_ADAPTER: _ExecutionPhase.ValueType  # 50
    """Initializing the adapter (warehouse connection and configuration)"""
    EXECUTION_PHASE_DEFER_HYDRATION: _ExecutionPhase.ValueType  # 60
    """Handling deferral. Fetching state source schemas from remote, hydrating relation, and schema cache"""
    EXECUTION_PHASE_TASK_GRAPH_BUILD: _ExecutionPhase.ValueType  # 70
    """Building the task graph from the schedule"""
    EXECUTION_PHASE_NODE_CACHE_HYDRATION: _ExecutionPhase.ValueType  # 80
    """Hydration of cached models, seeds, snapshots and sources"""
    EXECUTION_PHASE_RENDER: _ExecutionPhase.ValueType  # 90
    """Render SQL (also called `compile` in dbt core)"""
    EXECUTION_PHASE_ANALYZE: _ExecutionPhase.ValueType  # 100
    """SQL static analysis"""
    EXECUTION_PHASE_RUN: _ExecutionPhase.ValueType  # 110
    """Execution against the target database"""
    EXECUTION_PHASE_FRESHNESS_ANALYSIS: _ExecutionPhase.ValueType  # 120
    """Phases for other commands

    Freshness analysis of sources and models
    """
    EXECUTION_PHASE_LINEAGE: _ExecutionPhase.ValueType  # 130
    """Analysis of individual node lineages"""
    EXECUTION_PHASE_DEBUG: _ExecutionPhase.ValueType  # 140
    """Debugging connection correctness and availability to the warehouse"""

class ExecutionPhase(_ExecutionPhase, metaclass=_ExecutionPhaseEnumTypeWrapper):
    """A superset of all possible phases across all dbt commands.
    Note that not all phases are relevant to all commands.
    """

EXECUTION_PHASE_UNSPECIFIED: ExecutionPhase.ValueType  # 0
"""Do not use."""
EXECUTION_PHASE_CLEAN: ExecutionPhase.ValueType  # 10
"""Build/run flow phases

Cleaning output folders (e.g. the target directory)
"""
EXECUTION_PHASE_LOAD_PROJECT: ExecutionPhase.ValueType  # 20
"""dbt Project loading: analyzing dbt_project, profiles.yml and scanning files"""
EXECUTION_PHASE_PARSE: ExecutionPhase.ValueType  # 30
"""Parsing and macro name resolution of all dbt files"""
EXECUTION_PHASE_SCHEDULE: ExecutionPhase.ValueType  # 40
"""Schedule nodes based on selection criteria and dependencies."""
EXECUTION_PHASE_INIT_ADAPTER: ExecutionPhase.ValueType  # 50
"""Initializing the adapter (warehouse connection and configuration)"""
EXECUTION_PHASE_DEFER_HYDRATION: ExecutionPhase.ValueType  # 60
"""Handling deferral. Fetching state source schemas from remote, hydrating relation, and schema cache"""
EXECUTION_PHASE_TASK_GRAPH_BUILD: ExecutionPhase.ValueType  # 70
"""Building the task graph from the schedule"""
EXECUTION_PHASE_NODE_CACHE_HYDRATION: ExecutionPhase.ValueType  # 80
"""Hydration of cached models, seeds, snapshots and sources"""
EXECUTION_PHASE_RENDER: ExecutionPhase.ValueType  # 90
"""Render SQL (also called `compile` in dbt core)"""
EXECUTION_PHASE_ANALYZE: ExecutionPhase.ValueType  # 100
"""SQL static analysis"""
EXECUTION_PHASE_RUN: ExecutionPhase.ValueType  # 110
"""Execution against the target database"""
EXECUTION_PHASE_FRESHNESS_ANALYSIS: ExecutionPhase.ValueType  # 120
"""Phases for other commands

Freshness analysis of sources and models
"""
EXECUTION_PHASE_LINEAGE: ExecutionPhase.ValueType  # 130
"""Analysis of individual node lineages"""
EXECUTION_PHASE_DEBUG: ExecutionPhase.ValueType  # 140
"""Debugging connection correctness and availability to the warehouse"""
global___ExecutionPhase = ExecutionPhase

@typing.final
class PhaseExecuted(google.protobuf.message.Message):
    """Top-level event for reporting a build phase, with optional details."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PHASE_FIELD_NUMBER: builtins.int
    NODE_COUNT_TOTAL_FIELD_NUMBER: builtins.int
    NODE_COUNT_SKIPPED_FIELD_NUMBER: builtins.int
    NODE_COUNT_ERROR_FIELD_NUMBER: builtins.int
    phase: global___ExecutionPhase.ValueType
    """The current phase of execution."""
    node_count_total: builtins.int
    """Optional count of total individual nodes within the phase (when applicable)."""
    node_count_skipped: builtins.int
    """Optional count of skipped nodes within the phase (when applicable).
    Skipped means `node_outcome` was set to `NODE_OUTCOME_SKIPPED`.
    """
    node_count_error: builtins.int
    """Optional count of errored nodes within the phase (when applicable).
    Error means `node_outcome` was set to `NODE_OUTCOME_ERROR`.
    """
    def __init__(
        self,
        *,
        phase: global___ExecutionPhase.ValueType = ...,
        node_count_total: builtins.int | None = ...,
        node_count_skipped: builtins.int | None = ...,
        node_count_error: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_node_count_error", b"_node_count_error", "_node_count_skipped", b"_node_count_skipped", "_node_count_total", b"_node_count_total", "node_count_error", b"node_count_error", "node_count_skipped", b"node_count_skipped", "node_count_total", b"node_count_total"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_node_count_error", b"_node_count_error", "_node_count_skipped", b"_node_count_skipped", "_node_count_total", b"_node_count_total", "node_count_error", b"node_count_error", "node_count_skipped", b"node_count_skipped", "node_count_total", b"node_count_total", "phase", b"phase"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_node_count_error", b"_node_count_error"]) -> typing.Literal["node_count_error"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_node_count_skipped", b"_node_count_skipped"]) -> typing.Literal["node_count_skipped"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_node_count_total", b"_node_count_total"]) -> typing.Literal["node_count_total"] | None: ...

global___PhaseExecuted = PhaseExecuted
